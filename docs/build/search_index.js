var documenterSearchIndex = {"docs":
[{"location":"quickguide/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"To perform a state estimation (SE), a network data file (e.g. \"case3_unbalanced.dss\" in ../test/data/extra/networks) needs to be acquired, together with its related measurement file (e.g. \"case3_meas.csv\" in ../test/data/extra/measurements). The absolute path to the package is provided through the constant BASE_DIR. Network and measurement data will be merged and a SE can be run as follows:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"using PowerModelsDistribution, PowerModelsDistributionStateEstimation\r\nusing JuMP, Ipopt\r\n\r\n#full paths to files\r\nntw_path = joinpath(BASE_DIR, \"test/data/extra/networks/case3_unbalanced.dss\")\r\nmsr_path = joinpath(BASE_DIR, \"test/data/extra/measurements/case3_meas.csv\")\r\n\r\n#parse network data file\r\ndata = PowerModelsDistribution.parse_file(ntw_path; data_model=MATHEMATICAL)\r\n\r\n#add measurement data to network data file\r\nadd_measurements!(data, msr_path, actual_meas = true)\r\n\r\n#set state estimation settings\r\ndata[\"se_settings\"] = Dict{String,Any}(\"criterion\" => \"rwlav\", \"rescaler\" => 1)\r\n\r\n#set solver parameters\r\nslv = JuMP.optimizer_with_attributes(Ipopt.Optimizer, \"tol\"=>1e-6, \"print_level\"=>0)\r\n\r\n#run state estimation\r\nse_result = solve_acp_mc_se(data, slv)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The run commands return detailed results in the form of a dictionary, following PowerModelsDistribution format, and can be saved for future processing, like in se_result above.","category":"page"},{"location":"quickguide/#Accessing-Different-Formulations","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Different run functions correspond to different formulations. The function solve_acp_mc_se uses the AC Polar form, solve_acr_mc_se uses the AC rectangular, etc. Alternatively, the formulation type can directly be passed to the generic solve_mc_se function:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solve_mc_se(data, ACPUPowerModel, slv)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"It should be noted that not all solvers can handle all problem types. For example, to use the SDP formulation, you have to use a SDP-capable solver, such as the open-source solver SCS.","category":"page"},{"location":"quickguide/#Providing-a-Warm-Start","page":"Getting Started","title":"Providing a Warm Start","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Providing a (good) initial value to some or all optimization variables can reduce the number of solver iterations. PowerModelsDistributionStateEstimation provides the assign_start_to_variables! function.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"assign_start_to_variables!(data)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"assign_start_to_variables!(data, start_values_source)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Alternatively, the user can directly assign a value or vector (depending on the dimensions of the variable) in the data dictionary, under the key variablename_start. The example below shows how to do it for the vm and va variables.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"data = parse_file(\"case3_unbalanced.dss\"; data_model=MATHEMATICAL)\r\ndata[\"bus\"][\"2\"][\"vm_start\"] = [0.996, 0.996, 0.996]\r\ndata[\"bus\"][\"2\"][\"va_start\"] = [0.00, -2.0944, 2.0944]","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"It should be noted that providing a bad initial value might result in longer calculation times or convergence issues, so the start value assignment should be done cautiously. If no initial value is provided, a flat start is assigned by default. The default initial value of each variable is indicated in the function where the variable is defined, as the last argument of the comp_start_value function (this is valid for both imported PowerModelsDistribution and native PowerModelsDistributionStateEstimation variables).","category":"page"},{"location":"quickguide/#Updating-Variable-Bounds","page":"Getting Started","title":"Updating Variable Bounds","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"In constrained optimization, reducing the search space might be an effective way to reduce solver time. Search space reduction can be done by assigning bounds to the variables. This must also be done attentively, though, to make sure that the feasible space is not cut, i.e., that feasible solutions are not removed by this process. This can be avoided if good knowledge of the system is available or if some variable have particularly obvious bounds, e.g., voltage magnitude cannot be negative, so its lower bound can be set to 0 without risk. Similar to providing a warm start, it is to user discretion to assign meaningful and \"safe\" variable bounds. PowerModelsDistributionStateEstimation has functions that allow to define bounds on voltage magnitude, power generation (active and reactive) or power demand (active and reactive):","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"update_voltage_bounds!(data::Dict; v_min=0.0, v_max=Inf)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"update_generator_bounds!(data::Dict; p_min::Float64=0.0, p_max::Float64=Inf, q_min::Float64=-Inf, q_max::Float64=Inf)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"update_load_bounds!(data::Dict; p_min::Float64=0.0, p_max::Float64=Inf, q_min::Float64=-Inf, q_max::Float64=Inf)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"or, alternatively, all the above at once:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"update_all_bounds!(data::Dict; v_min::Float64=0.0, v_max::Float64=Inf, pg_min::Float64=0.0, pg_max::Float64=Inf, qg_min::Float64=-Inf, qg_max::Float64=Inf, pd_min::Float64=0.0, pd_max::Float64=Inf, qd_min::Float64=-Inf, qd_max::Float64=Inf)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Alternatively, the user can directly assign a value or vector (depending on the dimensions of the variable) in the data dictionary, under the key variablenamemin/variablenamemax. The example below shows how to do it for the active power.","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"data[\"load\"][\"1\"][\"pmax\"] = [1.0, 1.0, 1.0]\r\ndata[\"load\"][\"1\"][\"pmin\"] = [0.0, 0.0, 0.0]","category":"page"},{"location":"quickguide/#Updating-Residual-Bounds","page":"Getting Started","title":"Updating Residual Bounds","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Residuals are a type of variable that is specific to the state estimation problem (and not, e.g., of power flow studies). If you do not know what a residual is, please read the Problem Specifications section of the documentation. While the residuals as defined in the present package are always non-negative (default lower bound is 0), there is no default upper bound. A function is available to add customized upper bounds:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"assign_residual_ub!(data::Dict; chosen_upper_bound::Float64=100.0, rescale::Bool=false)","category":"page"},{"location":"#entsoeAPI","page":"Home","title":"entsoeAPI","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia API to retreive data from the ENTSO-E transparancy platform using the ENTSOE-E API. Documentation for the ENTSO-E can be found on https://transparency.entsoe.eu/content/static_content/Static%20content/web%20api/Guide.html","category":"page"},{"location":"#Prerequisites","page":"Home","title":"Prerequisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download and install the Julia API for the ENTSO-E transparency platform first using the following link\nCreate an account in the ENTSO-E transparency platform\nRequest an API key by sending an email to transparency@entsoe.eu with “Restful API access” in the subject line. In the email body state your registered email address. You will receive an email when you have been provided with the API key. The key is then visible in your ENTSO-E account under “Web API Security Token”.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"entsoeAPI.jl is the main file which contains the following functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function initialize_key(APIkey::String)\r\n\r\nfunction actual_total_load(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction day_ahead_total_load(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction week_ahead_total_load(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction month_ahead_total_load(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction year_ahead_total_load(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction year_ahead_margin(outBiddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\n\r\nfunction forecasted_capacity(contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction offered_capacity(auctionType::String, contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, auctionCategory::String = \"\", update_DateAndOrTime::DateTime = DateTime(0), classificationSequence_AttributeInstanceComponentPosition::String = \"\")\r\nfunction flowbased(processType::String, domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction intraday_transfer_limits(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction explicit_allocation_information_capacity(businessType::String, contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, auctionCategory::String = \"\", classificationSequence_AttributeInstanceComponentPosition::String = \"\")\r\nfunction explicit_allocation_information_revenue(contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction total_capacity_nominated(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction total_capacity_already_allocated(contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, auctionCategory::String = \"\")\r\nfunction day_ahead_prices(domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction implicit_auction_net_positions(businessType::String, contract_MarketAgreementType::String, domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction implicit_auction_congestion_income(businessType::String, contract_MarketAgreementType::String, domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction total_commercial_schedules(contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction phyiscal_flows(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction capacity_allocated_outside_EU(auctionType::String, contract_MarketAgreementType::String, in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, auctionCategory::String = \"\", classificationSequence_AttributeInstanceComponentPosition::String = \"\")\r\n\r\nfunction expansion_and_dismantling(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", docStatus::String = \"\")\r\nfunction redispatching(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\")\r\nfunction countertrading(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction congestion_costs(domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\")\r\n\r\nfunction installed_generation_capacity_aggregated(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction installed_generation_capacity_per_unit(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction day_ahead_aggregated_generation(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction day_ahead_generation_forecasts_wind_solar(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction current_generation_forecasts_wind_solar(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction intraday_generation_forecasts_wind_solar(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction actual_generation_per_generation_unit(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\", registeredResource::String = \"\")\r\nfunction aggregated_generation_per_type(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\")\r\nfunction aggregated_filling_rate(in_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\n\r\nfunction production_generation_units(biddingZone_Domain::Union{mappings.Area, String}, implementation_DateAndOrTime::DateTime, psrType::String = \"\")\r\n\r\nfunction current_balancing_state(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction balancing_energy_bids(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, processType::String)\r\nfunction aggregated_balancing_energy_bids(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, processType::String)\r\nfunction procured_balancing_capacity(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, type_MarketAgreementType::String = \"\")\r\nfunction crossZonal_balancing_capacity(acquiring_Domain::Union{mappings.Area, String}, connecting_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction volumes_and_prices_contracted_reserves(type_MarketAgreementType::String, processType::String, controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, psrType::String = \"\", offset::Int = 0)\r\nfunction volumes_contracted_reserves(type_MarketAgreementType::String, controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", psrType::String = \"\", offset::Int = 0)\r\nfunction prices_contracted_reserves(type_MarketAgreementType::String, controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", psrType::String = \"\", offset::Int = 0)\r\nfunction accepted_aggregated_offers(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", psrType::String = \"\")\r\nfunction activated_balancing_energy(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", psrType::String = \"\")\r\nfunction prices_activated_balancing_energy(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", psrType::String = \"\")\r\nfunction imbalance_prices(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction total_imbalance_volumes(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction financial_expenses(controlArea_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction crossBorder_balancing(acquiring_Domain::Union{mappings.Area, String}, connecting_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction FCR_total_capacity(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction share_capacity_FCR(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction contracted_reserve_capacity_FCR(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction FRR_actual_capacity(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction RR_actual_capacity(area_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction query_sharing_of_reserves(processType::String, acquiring_Domain::Union{mappings.Area, String}, connecting_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime)\r\nfunction balancing_border_capacity_limitations()\r\nfunction permanent_allocation_limitations_HVDC()\r\nfunction netted_and_exchanged_volumes()\r\n\r\nfunction unavailability_consumption_units(biddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\")\r\nfunction unavailability_generation_units(biddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", docStatus::String = \"\", periodStartUpdate::DateTime = DateTime(0), periodEndUpdate::DateTime = DateTime(0), registeredResource::String = \"\", mRID::String = \"\", offset::Int = 0)\r\nfunction unavailability_production_units(biddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", docStatus::String = \"\", periodStartUpdate::DateTime = DateTime(0), periodEndUpdate::DateTime = DateTime(0), registeredResource::String = \"\", mRID::String = \"\", offset::Int = 0)\r\nfunction unavailability_offshore_grid(biddingZone_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, docStatus::String = \"\", periodStartUpdate::DateTime = DateTime(0), periodEndUpdate::DateTime = DateTime(0), mRID::String = \"\", offset::Int = 0)\r\nfunction unavailability_transmission_infrastructure(in_Domain::Union{mappings.Area, String}, out_Domain::Union{mappings.Area, String}, periodStart::DateTime, periodEnd::DateTime, businessType::String = \"\", docStatus::String = \"\", periodStartUpdate::DateTime = DateTime(0), periodEndUpdate::DateTime = DateTime(0), mRID::String = \"\", offset::Int = 0)\r\nfunction fallBacks()","category":"page"},{"location":"","page":"Home","title":"Home","text":"The initialize_key(APIkey::String) function saves your personal security token in the GETconstructor.jl file. In this way it is possbile to use the API without entering the security token everytime.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All the other functions retreive a specific set of data from the transparancy platform. This happens in 2 steps: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A HTTP-request is formed with the functions in the GETconstructor.jl file. This request is sent to the ENTSO-E API which returns the requested data in XML format.\nThe XML data is parsed with the functions in the XMLparser.jl file. The return format is not exactly the same for each function. But it's always a combination of dataframes and dicitionaries (The exact format can be found in the documentation per function).","category":"page"},{"location":"#Arguments","page":"Home","title":"Arguments","text":"","category":"section"},{"location":"#Domains","page":"Home","title":"Domains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Domains can be entered in the following formats:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Area object as defined in mappings.jl\nEIC-code ad defined on https://www.entsoe.eu/data/energy-identification-codes-eic/eic-approved-codes/\nDisplay name as defined on https://www.entsoe.eu/data/energy-identification-codes-eic/eic-approved-codes/","category":"page"},{"location":"","page":"Home","title":"Home","text":"Important to know is that the list in mappings.jl isn't complete and that the domains are always evolving as well. If you want to add a missing domain to mappings.jl you have to do this as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"display_name = Area(\"display name\", \"EIC-code\", \"description\", TimeZone)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example for Belgium:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BE = Area(\"BE\", \"10YBE----------2\", \"Belgium, Elia BZ / CA / MBA\", TimeZone(\"Europe/Brussels\"))","category":"page"},{"location":"#Dates-and-Times","page":"Home","title":"Dates and Times","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dates and TImes need to be entered as a DateTime() object. The correct timezone is choosen automatically based on the entered domain. More information on the DateTime()object and the Dates packages can be found on https://docs.julialang.org/en/v1/stdlib/Dates/","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hereafter an example will be discussed to clarify how to use the API. We want to get the actual load data from the Czech Republic between 31/12/2015 23:00 and 31/12/2016 23:00. First we have to initialize our personal security token:","category":"page"},{"location":"","page":"Home","title":"Home","text":"APIkey = \"YOUR_PERSONAL_TOKEN\"\r\nentsoeAPI.initialize_key(APIkey)","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the token is initialized, we can try to retreive the actual data. This is done in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"entsoeAPI.actual_total_load(\"10YCZ-CEPS-----N\", DateTime(2015,12,31,23,00), DateTime(2016,12,31,23,00))","category":"page"}]
}
